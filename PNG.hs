{-# LANGUAGE OverloadedStrings #-}

module PNG (
    parseFromFile
) where


import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as L
import Data.Binary.Get (runGet, getWord32be, getWord8)
import Data.Attoparsec.ByteString as A
import Data.Word


-- A reference image type.  It is an abstraction capable of representing any
-- image (grayscale, trucolor with alpha, etc.).  Different channels can
-- have different sample depths.
data RefImg = RefImg {
    refData :: B.ByteString,
    refWidth :: Int,
    refHeight :: Int,
    refRed :: Channel,
    refBlue :: Channel,
    refGreen :: Channel,
    refAlpha :: Maybe Channel
}


-- A channel is a uniform color with an intensity given by a sample depth, 
-- which is the number of bits used to represent the color.
data Channel = Channel {
    sampleDepth :: Int -- between 1 and 16 bits
}


-- A data type containing the necessary information for producing a PNG data
-- stream.
data PNGImg = TruecolorWithAlphaImg | GrayscaleWithAlphaImg | TruecolorImg |
    GrayscaleImg | IndexedColorImg deriving (Show)


-- A data type for representing the results from parsing any PNG data stream. 
-- It excludes the PNG signature that starts every stream and the IEND chunk
-- that ends it, as these are the same for every PNG data stream and contain
-- no additional information.
--data PNGDataStream = PNGDataStream IHDRChunk ANCIChunk [IDATChunk] deriving (Show)
data PNGDataStream = PNGDataStream IHDRChunk [IDATChunk] deriving (Show)


-- The first chunk in all png data streams
data IHDRChunk = IHDRChunk {
    ihdrWidth :: Int,                  -- image width in pixels
    ihdrHeight :: Int,                 -- image height in pixels
    ihdrBitDepth :: BitDepth,          -- bits per sample or pallete index.
    ihdrColorType :: ColorType,
    ihdrCompressionMethod :: B.ByteString,
    ihdrFilterMethod :: B.ByteString,
    ihdrInterlaceMethod :: B.ByteString,
    ihdrCRC :: B.ByteString
}
instance Show IHDRChunk where
    show c = "(IHDRChunk " ++
             " w=" ++ show (ihdrWidth c) ++
             " h=" ++ show (ihdrHeight c) ++
             " bitdepth=" ++ show (ihdrBitDepth c) ++
             " colortype=" ++ show (ihdrColorType c) ++
             " compressionmethod=" ++ conv (ihdrCompressionMethod c) ++
             " filtermethod=" ++ conv (ihdrFilterMethod c) ++
             " interlacemethod=" ++ conv (ihdrInterlaceMethod c) ++
             " crc=?)"
             where conv = show . runGet getWord8 . L.fromStrict 


data IDATChunk = IDATChunk {
    idatLength :: Int,
    idatData :: B.ByteString,
    idatCRC :: B.ByteString} 
instance Show IDATChunk where
    show c = "(IDATChunk length=" ++ (show (idatLength c)) ++ ")"


-- A data type for representing ancillary chunks.  Ancillary chunks provide
-- additional information about an image that are generated by encoders and
-- interpreted and possibly used by decoders.  The ancillary chunk types are:
-- tRNS - transparency information
-- cHRM -
-- gAMA -
-- iCCP -
-- sBIT -
-- sRGB -
-- iTXt -
-- tEXt -
-- zTXt -
-- bKGD -
-- hIST -
-- pHYs -
-- sPLT -
-- tIME -
data ANCIChunk = ANCIChunk {
    anciLength :: Int,
    anciType :: B.ByteString,
    anciData :: B.ByteString,
    anciCRC :: B.ByteString
}
instance Show ANCIChunk where
    show c = "(ANCIChunk length=" ++ (show (anciLength c)) ++ ")"


data Palette = Palette [(Red, Green, Blue)] AlphaTable

type AlphaTable = [(Alpha, Red, Blue, Green)]
type Alpha = Int
type Red = Int
type Blue = Int
type Green = Int

-- The PNG size in bytes were it to be written to 
size :: PNGImg -> Int
size = undefined


empty :: PNGImg
empty = TruecolorWithAlphaImg

isRGBA :: PNGImg -> Bool
isRGBA = undefined

isRGB :: PNGImg -> Bool
isRGB = undefined


-- Convert a PNG to a bytestring
-- The steps in encoding are:
-- 1.  Pass extraction
-- 2.  Scanline serialization
-- 3.  Filtering
-- 4.  Compression
-- 5.  Chunking
-- 6.  Datastream construction
encode :: PNGImg -> B.ByteString
encode = passExtraction >> scanlineSerialization >> filtering >>
    compression >> chunking >> datastreamConstruction

passExtraction = undefined
scanlineSerialization = undefined
filtering = undefined
compression = undefined
chunking = undefined
datastreamConstruction = undefined

-- Alpha channel separation is the examination of the alpha channel to
-- determine if all of the values are maximum (2^(sample depth) - 1).  If so,
-- then the alpha channel can be removed.
--
-- This step is not required, and some implementations may not wish to
-- use it as it removes an alpha channel (even though it is contributing
-- nothing).
alphaSep :: PNGImg -> PNGImg
alphaSep = undefined


-- Perform indexing.  This step is not required.  If it is performed, it is
-- done in place of rgb merging and alpha compaction.  If it is not performed,
-- then rgb merging and alpha composition must be performed.  Indexing is
-- the creation of a palatte of color values, and a single array of 8-bit
-- values that contain indices into the palette.  If an alpha channel is
-- present there is also a parallel table of alpha values.
--
-- The alpha table and palette can be reordered to put those pixels with
-- maximum alpha values at the bottom, and then the alpha table can be
-- shortened and not include these values.
--
-- Index tables may be included even if indexing isn't used to encode the
-- image, to assist with color mapping if a display has limited colors.
indexing :: PNGImg -> PNGImg
indexing = undefined


-- If the RGB channels all have the same sample depth, and for every pixel
-- the red, green, and blue values are the same, merge the channels into
-- a single grayscale channel.
-- If this step is performed, then it must be followed
-- by alpha compaction.
rgbMerging :: PNGImg -> PNGImg
rgbMerging = undefined


-- For non-indexed images, if there exists an RGB (or greyscale) value such
-- that all pixels with that value are fully transparent while all other
-- pixels are fully opaque, then the alpha channel can be represented more
-- compactly by merely identifying the RGB (or greyscale) value that is
-- transparent.
--
-- This step is always preceded by rgb merging.
alphaComp :: PNGImg -> PNGImg
alphaComp = undefined


-- Perform sample depth scaling.  This is the last step in conversion of
-- a reference image into a PNG image. It is always performed.
depthScale :: PNGImg -> PNGImg
depthScale = undefined


-- Returns true if indexing would lead to a smaller image.   Indexing should
-- be used if only if:
-- 1. The number of distinct pixel values (rgb(a) combinations) is 256 or less.
-- 2. All rgb sample depths are not greater than 8
-- 3. The alpha channel sample depth is absent, or is 8, or all values are
--    either maximum or 0.
shouldIndex :: PNGImg -> Bool
shouldIndex = undefined


-- prepare a summary of information about the PNG 
pngInfo :: PNGImg -> String
pngInfo = undefined


-- For IndexedColor images, it is the number of bits per palette index.  For
-- other images it is the number of bits per sample in the image (a sample
-- being a pixel value in a particular color channel). 
type BitDepth = Int


-- a single-byte integer that defines the PNG image type.  Only certain
-- bit depths are allowed for a given color type:
-- PNG image type       PNG color type          allowed bit depths
-- grayscale            0                       1,2,4,8,16
-- truecolor            2                       8,16
-- indexed color        3                       1,2,4,8
-- grayscale with alpha 4                       8,16
-- truecolor with alpha 6                       8,16
data ColorType = Grayscale |
                 Truecolor |
                 IndexedColor |
                 GrayscaleWithAlpha |
                 TruecolorWithAlpha deriving (Eq, Show)


bitDepths = [(Grayscale,[1,2,3,8,16]),
             (Truecolor,[8,16]),
             (IndexedColor,[1,2,4,8]),
             (GrayscaleWithAlpha,[8,16]),
             (TruecolorWithAlpha,[8,16])]


-- there are restrictions on the bit depths allowed for different color types.
-- grayscale


-- a chunk consists of:
--
-- length - a four byte unsigned int giving the number of bytes in the chunk's
--          data field.
--
-- chunk type - a four byte sequence defining the chunk type.  Each byte
--              of a chunk type is restricted to the decimal values 65 to 90
--              and 97 to 12.  These correspond to the uppercase and lowercase
--              ISO 646 letters (A-Z and a-z) respectively, for convenience
--              in description and examination of PNG datastreams.  The chunk
--              types should be treated as strict binary values not by their
--              ISO 646 letter equivalents.
--
--              critical chunk types:
--              IHDR - image header, first chunk in PNG datastream
--              PLTE - palette table for indexed PNG images.
--              IDAT - image data chunks
--              IEND - image trailer, last chunk in a PNG data stream
--
--              ancillary chunk types:
--              tRNS - transparency information
--              cHRM, gAMA, iCCP, sBIT, sRGB - color space information
--              iTXt, tEXt, zTXt - textual information
--              bKGD, hIST, pHYs, sPLT - miscellaneous informaiton
--              tIME - timestamp information
--
-- chunk data - the data bytes appropriate to the chunk type, if any.  This
--              field can be of zero length.
-- chunk CRC - a four byte cyclic redundancey code calaculated on the
--             preceding bytes in the chunk, including the chunk type field
--             and chunk data fields but not including the length field.
--
data Chunk = Chunk {
    chunkLength :: Int,
    chunkType :: ChunkType, 
    chunkData :: B.ByteString,
    chunkCRC :: Word32
}


data ChunkType = IHDRType | IFTRType


-- The PNG signature is an 8 byte value that must be present at the start
-- of all valid PNG files.
pngSignature = B.pack [137,80,78,71,13,10,26,10]


parseFromFile :: FilePath -> IO (Result PNGDataStream)
parseFromFile fp = B.readFile fp >>= \contents -> 
    return $ parsePNGDataStream contents


-- parse a PNG data stream (such as a PNG file) into a 
-- format that references the important parts of the data stream
parsePNGDataStream :: B.ByteString -> Result PNGDataStream
parsePNGDataStream = parse pngDataStreamParser


-- parses a byte stream into a PNG image
pngDataStreamParser :: Parser PNGDataStream
pngDataStreamParser = do
    _    <- sigParser -- discard the PNG signature after it matches
    ihdr <- ihdrParser
    -- anci <- anciParser
    ds   <- manyTill idatParser iendParser
    --return $ PNGDataStream ihdr anci ds
    return $ PNGDataStream ihdr ds


sigParser :: Parser B.ByteString
sigParser = string pngSignature


lengthParser :: Parser Int
lengthParser = do
    str <- A.take 4
    return $ fromIntegral $ runGet getWord32be (L.fromStrict str)


bitDepthParser :: Parser BitDepth
bitDepthParser = do
    b <- A.anyWord8
    if b `elem` [1,2,4,8,16]
        then return $ fromIntegral b
        else fail "invalid bit depth"


colorTypeParser :: Parser ColorType
colorTypeParser = do
    c <- A.anyWord8
    case c of
        0 -> return Grayscale
        2 -> return Truecolor
        3 -> return IndexedColor
        4 -> return GrayscaleWithAlpha
        6 -> return TruecolorWithAlpha
        _ -> fail "unrecognized color type"

-- parses an IHDR chunk.  This chunk must immediately follow the PNG
-- signature and must always be present.
ihdrParser :: Parser IHDRChunk
ihdrParser = do
    _ <- lengthParser
    _ <- string "IHDR"
    w <- lengthParser
    h <- lengthParser
    b <- bitDepthParser
    c <- colorTypeParser
    let maybeDepths = lookup c bitDepths
    case maybeDepths of
        Nothing -> fail "bit depths not found"
        Just depths -> if b `notElem` depths
            then fail "invalid bit depth for color type"
            else do
                m <- A.take 1
                f <- A.take 1
                i <- A.take 1
                crc <- crcParser
                return IHDRChunk {
                    ihdrWidth=w, ihdrHeight=h, ihdrBitDepth=b, ihdrColorType=c,
                    ihdrCompressionMethod=m, ihdrFilterMethod=f,
                    ihdrInterlaceMethod=i, ihdrCRC=crc}


-- Parse an ancillary chunk.  These are chunks whose ancillary bit of their
-- chunk type is lowercase (bit 5 is 1).
anciParser :: Parser ANCIChunk
anciParser = do
    x <- lengthParser
    atype <- A.take 4 
    --first <- A.satisfy (\letter -> letter >= 97 && letter <= 122) -- lowercase
    --rest <- A.take 3
    d <- A.take x
    crc <- crcParser
    --return ANCIChunk {anciType=B.cons first rest, anciData=d, anciCRC=crc}
    return ANCIChunk {anciLength=x, anciType=atype, anciData=d, anciCRC=crc}


crcParser :: Parser B.ByteString
crcParser = A.take 4


idatParser :: Parser IDATChunk
idatParser = do
    x <- lengthParser
    _ <- string "IDAT"
    d <- A.take x
    crc <- crcParser
    return IDATChunk {idatLength = x, idatData = d, idatCRC = crc}


iendParser :: Parser ()
iendParser = lengthParser >> string "IEND" >> return ()
